// blockchain/contracts/PramaanAttendance.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./verifier.sol"; // The ZK verifier contract generated by ZoKrates

contract PramaanAttendance {
    // Structs
    struct AttendanceProof {
        address scholar;
        string scholarDID;
        uint256 timestamp;
        bytes32 biometricCommitment;
        bool isCheckIn;
        string ipfsHash; // For storing additional metadata
        bool verified;
    }

    struct ScholarProfile {
        string did;
        string scholarId;
        bytes32 biometricHashCommitment;
        bool isActive;
        uint256 registrationTime;
    }

    // State variables
    mapping(address => ScholarProfile) public scholars;
    mapping(string => address) public didToAddress;
    mapping(uint256 => AttendanceProof) public attendanceRecords;
    mapping(address => uint256[]) public scholarAttendanceIds;
    
    uint256 public attendanceCounter;
    address public admin;
    address public verifierContract;
    
    // Events
    event ScholarRegistered(address indexed scholar, string did, uint256 timestamp);
    event AttendanceMarked(
        address indexed scholar, 
        uint256 indexed attendanceId, 
        bool isCheckIn, 
        uint256 timestamp
    );
    event AttendanceVerified(uint256 indexed attendanceId, bool success);
    
    // Modifiers
    modifier onlyAdmin() {
        require(msg.sender == admin, "Only admin can perform this action");
        _;
    }
    
    modifier onlyRegisteredScholar() {
        require(scholars[msg.sender].isActive, "Scholar not registered");
        _;
    }
    
    constructor(address _verifierContract) {
        admin = msg.sender;
        verifierContract = _verifierContract;
    }
    
    // Scholar Registration
    function registerScholar(
        address _scholarAddress,
        string memory _did,
        string memory _scholarId,
        bytes32 _biometricHashCommitment
    ) external onlyAdmin {
        require(!scholars[_scholarAddress].isActive, "Scholar already registered");
        require(didToAddress[_did] == address(0), "DID already registered");
        
        scholars[_scholarAddress] = ScholarProfile({
            did: _did,
            scholarId: _scholarId,
            biometricHashCommitment: _biometricHashCommitment,
            isActive: true,
            registrationTime: block.timestamp
        });
        
        didToAddress[_did] = _scholarAddress;
        
        emit ScholarRegistered(_scholarAddress, _did, block.timestamp);
    }
    
    // Mark Attendance with ZK Proof
    function markAttendance(
        bool _isCheckIn,
        bytes32 _biometricCommitment,
        string memory _ipfsHash,
        uint[2] memory a,
        uint[2][2] memory b,
        uint[2] memory c,
        uint[3] memory input
    ) external onlyRegisteredScholar returns (uint256) {
        // Verify the ZK proof
        Verifier verifier = Verifier(verifierContract);
        bool proofValid = verifier.verifyTx(
            Verifier.Proof(
                Pairing.G1Point(a[0], a[1]),
                Pairing.G2Point([b[0][0], b[0][1]], [b[1][0], b[1][1]]),
                Pairing.G1Point(c[0], c[1])
            ),
            input
        );
        
        require(proofValid, "Invalid ZK proof");
        
        // Create attendance record
        uint256 attendanceId = attendanceCounter++;
        attendanceRecords[attendanceId] = AttendanceProof({
            scholar: msg.sender,
            scholarDID: scholars[msg.sender].did,
            timestamp: block.timestamp,
            biometricCommitment: _biometricCommitment,
            isCheckIn: _isCheckIn,
            ipfsHash: _ipfsHash,
            verified: true
        });
        
        scholarAttendanceIds[msg.sender].push(attendanceId);
        
        emit AttendanceMarked(msg.sender, attendanceId, _isCheckIn, block.timestamp);
        emit AttendanceVerified(attendanceId, true);
        
        return attendanceId;
    }
    
    // Query Functions
    function getScholarAttendanceCount(address _scholar) external view returns (uint256) {
        return scholarAttendanceIds[_scholar].length;
    }
    
    function getScholarAttendanceHistory(
        address _scholar,
        uint256 _offset,
        uint256 _limit
    ) external view returns (AttendanceProof[] memory) {
        uint256[] memory attendanceIds = scholarAttendanceIds[_scholar];
        uint256 totalRecords = attendanceIds.length;
        
        if (_offset >= totalRecords) {
            return new AttendanceProof[](0);
        }
        
        uint256 end = _offset + _limit;
        if (end > totalRecords) {
            end = totalRecords;
        }
        
        AttendanceProof[] memory history = new AttendanceProof[](end - _offset);
        
        for (uint256 i = _offset; i < end; i++) {
            history[i - _offset] = attendanceRecords[attendanceIds[i]];
        }
        
        return history;
    }
    
    function verifyAttendanceProof(uint256 _attendanceId) external view returns (
        bool exists,
        bool verified,
        address scholar,
        uint256 timestamp
    ) {
        AttendanceProof memory proof = attendanceRecords[_attendanceId];
        exists = proof.timestamp > 0;
        verified = proof.verified;
        scholar = proof.scholar;
        timestamp = proof.timestamp;
    }
    
    // Admin Functions
    function deactivateScholar(address _scholar) external onlyAdmin {
        scholars[_scholar].isActive = false;
    }
    
    function updateVerifierContract(address _newVerifier) external onlyAdmin {
        verifierContract = _newVerifier;
    }
}

// blockchain/scripts/deploy.js
const { ethers } = require("hardhat");
const fs = require("fs");
const path = require("path");

async function main() {
    console.log("Deploying Pramaan Attendance System Contracts...");
    
    // Deploy Verifier contract first
    const Verifier = await ethers.getContractFactory("Verifier");
    const verifier = await Verifier.deploy();
    await verifier.deployed();
    console.log("Verifier deployed to:", verifier.address);
    
    // Deploy PramaanAttendance contract
    const PramaanAttendance = await ethers.getContractFactory("PramaanAttendance");
    const pramaanAttendance = await PramaanAttendance.deploy(verifier.address);
    await pramaanAttendance.deployed();
    console.log("PramaanAttendance deployed to:", pramaanAttendance.address);
    
    // Save deployment addresses
    const deploymentInfo = {
        network: network.name,
        verifier: verifier.address,
        pramaanAttendance: pramaanAttendance.address,
        deployedAt: new Date().toISOString()
    };
    
    fs.writeFileSync(
        path.join(__dirname, "../deployments.json"),
        JSON.stringify(deploymentInfo, null, 2)
    );
    
    console.log("Deployment info saved to deployments.json");
}

main()
    .then(() => process.exit(0))
    .catch((error) => {
        console.error(error);
        process.exit(1);
    });

// blockchain/hardhat.config.js
require("@nomiclabs/hardhat-waffle");
require("@nomiclabs/hardhat-ethers");
require("dotenv").config();

module.exports = {
    solidity: {
        version: "0.8.19",
        settings: {
            optimizer: {
                enabled: true,
                runs: 200
            }
        }
    },
    networks: {
        localhost: {
            url: "http://127.0.0.1:8545"
        },
        polygon_mumbai: {
            url: process.env.POLYGON_MUMBAI_RPC || "https://rpc-mumbai.maticvigil.com",
            accounts: process.env.PRIVATE_KEY ? [process.env.PRIVATE_KEY] : [],
            chainId: 80001
        },
        polygon_mainnet: {
            url: process.env.POLYGON_MAINNET_RPC || "https://polygon-rpc.com",
            accounts: process.env.PRIVATE_KEY ? [process.env.PRIVATE_KEY] : [],
            chainId: 137
        }
    }
};

// services/blockchainService.js
import { ethers } from 'ethers';
import PramaanAttendanceABI from '../blockchain/artifacts/contracts/PramaanAttendance.sol/PramaanAttendance.json';
import deployments from '../blockchain/deployments.json';

class BlockchainService {
    constructor() {
        this.provider = null;
        this.signer = null;
        this.contract = null;
        this.isInitialized = false;
    }

    async initialize() {
        try {
            // Use appropriate provider based on environment
            if (process.env.NODE_ENV === 'production') {
                // For production, use Polygon
                this.provider = new ethers.providers.JsonRpcProvider(
                    process.env.POLYGON_RPC_URL
                );
            } else {
                // For development, use local hardhat node
                this.provider = new ethers.providers.JsonRpcProvider(
                    'http://localhost:8545'
                );
            }

            // Initialize contract instance
            this.contract = new ethers.Contract(
                deployments.pramaanAttendance,
                PramaanAttendanceABI.abi,
                this.provider
            );

            this.isInitialized = true;
            console.log('Blockchain service initialized');
        } catch (error) {
            console.error('Failed to initialize blockchain service:', error);
            throw error;
        }
    }

    // Get contract with signer for write operations
    async getContractWithSigner(privateKey) {
        const wallet = new ethers.Wallet(privateKey, this.provider);
        return this.contract.connect(wallet);
    }

    // Register a scholar on blockchain
    async registerScholarOnChain(scholarData, adminPrivateKey) {
        try {
            const contractWithSigner = await this.getContractWithSigner(adminPrivateKey);
            
            const tx = await contractWithSigner.registerScholar(
                scholarData.walletAddress,
                scholarData.did,
                scholarData.scholarId,
                scholarData.biometricHashCommitment
            );
            
            const receipt = await tx.wait();
            return {
                success: true,
                transactionHash: receipt.transactionHash,
                blockNumber: receipt.blockNumber
            };
        } catch (error) {
            console.error('Failed to register scholar on chain:', error);
            throw error;
        }
    }

    // Store attendance proof on blockchain
    async storeAttendanceProof(attendanceData, zkProof, scholarPrivateKey) {
        try {
            const contractWithSigner = await this.getContractWithSigner(scholarPrivateKey);
            
            // Upload metadata to IPFS (optional)
            const ipfsHash = await this.uploadToIPFS({
                scholarId: attendanceData.scholarId,
                timestamp: attendanceData.timestamp,
                location: attendanceData.location,
                additionalData: attendanceData.additionalData
            });
            
            const tx = await contractWithSigner.markAttendance(
                attendanceData.isCheckIn,
                attendanceData.biometricCommitment,
                ipfsHash,
                zkProof.a,
                zkProof.b,
                zkProof.c,
                zkProof.publicSignals
            );
            
            const receipt = await tx.wait();
            
            // Extract attendance ID from events
            const event = receipt.events.find(e => e.event === 'AttendanceMarked');
            const attendanceId = event.args.attendanceId.toString();
            
            return {
                success: true,
                attendanceId,
                transactionHash: receipt.transactionHash,
                blockNumber: receipt.blockNumber,
                ipfsHash
            };
        } catch (error) {
            console.error('Failed to store attendance proof:', error);
            throw error;
        }
    }

    // Verify attendance proof from blockchain
    async verifyAttendanceProof(attendanceId) {
        try {
            const result = await this.contract.verifyAttendanceProof(attendanceId);
            return {
                exists: result.exists,
                verified: result.verified,
                scholar: result.scholar,
                timestamp: new Date(result.timestamp.toNumber() * 1000)
            };
        } catch (error) {
            console.error('Failed to verify attendance proof:', error);
            throw error;
        }
    }

    // Get scholar attendance history
    async getScholarAttendanceHistory(scholarAddress, offset = 0, limit = 50) {
        try {
            const history = await this.contract.getScholarAttendanceHistory(
                scholarAddress,
                offset,
                limit
            );
            
            return history.map(record => ({
                scholar: record.scholar,
                scholarDID: record.scholarDID,
                timestamp: new Date(record.timestamp.toNumber() * 1000),
                biometricCommitment: record.biometricCommitment,
                isCheckIn: record.isCheckIn,
                ipfsHash: record.ipfsHash,
                verified: record.verified
            }));
        } catch (error) {
            console.error('Failed to get attendance history:', error);
            throw error;
        }
    }

    // Upload metadata to IPFS (using Pinata or similar service)
    async uploadToIPFS(data) {
        try {
            // Implementation depends on IPFS service being used
            // Example using Pinata:
            const response = await fetch('https://api.pinata.cloud/pinning/pinJSONToIPFS', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${process.env.PINATA_JWT}`
                },
                body: JSON.stringify({
                    pinataContent: data,
                    pinataMetadata: {
                        name: `attendance-${data.scholarId}-${data.timestamp}`
                    }
                })
            });
            
            const result = await response.json();
            return result.IpfsHash;
        } catch (error) {
            console.error('Failed to upload to IPFS:', error);
            // Return empty string if IPFS upload fails
            return '';
        }
    }
}

export default new BlockchainService();

// Updated server.js endpoints for blockchain integration
// Add these to your existing server.js file

import blockchainService from './services/blockchainService.js';

// Initialize blockchain service
await blockchainService.initialize();

// Blockchain-integrated registration endpoint
app.post('/api/scholar/register-blockchain', authenticateToken, authenticateAdmin, async (req, res) => {
    try {
        const { scholarId, name, email, department, supervisor, biometricData, walletAddress } = req.body;
        
        // First register in traditional database
        const biometricHash = await zkpManager.generateBiometricHash(biometricData);
        const did = `did:pramaan:${crypto.randomBytes(8).toString('hex')}`;
        const zkpPublicKey = crypto.randomBytes(32).toString('hex');
        
        const scholar = new Scholar({
            scholarId,
            name,
            email,
            department,
            supervisor,
            biometricHash: biometricHash.hash,
            did,
            zkpPublicKey
        });
        
        await scholar.save();
        
        // Register on blockchain
        const blockchainResult = await blockchainService.registerScholarOnChain({
            walletAddress,
            did,
            scholarId,
            biometricHashCommitment: ethers.utils.keccak256(
                ethers.utils.toUtf8Bytes(biometricHash.hash)
            )
        }, process.env.ADMIN_PRIVATE_KEY);
        
        res.json({
            message: 'Scholar registered successfully on blockchain',
            scholarId,
            did,
            transactionHash: blockchainResult.transactionHash,
            blockNumber: blockchainResult.blockNumber
        });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// Blockchain-integrated attendance marking
app.post('/api/attendance/mark-blockchain', async (req, res) => {
    try {
        const { scholarId, biometricData, location, walletPrivateKey } = req.body;
        
        const scholar = await Scholar.findOne({ scholarId });
        if (!scholar) {
            return res.status(404).json({ error: 'Scholar not found' });
        }
        
        // Generate and verify ZK proof
        const providedBiometricHash = await zkpManager.generateBiometricHash(biometricData);
        const nonce = Date.now();
        const proof = await zkpManager.generateProof(
            providedBiometricHash.hash,
            [scholar.biometricHash.slice(0, 16), scholar.biometricHash.slice(16, 32)],
            nonce
        );
        
        const isValid = await zkpManager.verifyProof(proof, proof.publicSignals);
        if (!isValid) {
            return res.status(401).json({ error: 'Biometric verification failed' });
        }
        
        // Check for existing attendance
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        
        const existingAttendance = await Attendance.findOne({
            scholarId,
            checkIn: { $gte: today }
        });
        
        const isCheckIn = !existingAttendance || existingAttendance.checkOut;
        
        // Store on blockchain
        const blockchainResult = await blockchainService.storeAttendanceProof({
            scholarId,
            timestamp: Date.now(),
            location,
            isCheckIn,
            biometricCommitment: ethers.utils.keccak256(
                ethers.utils.toUtf8Bytes(providedBiometricHash.hash)
            ),
            additionalData: { nonce }
        }, {
            a: proof.proof.a,
            b: proof.proof.b,
            c: proof.proof.c,
            publicSignals: proof.publicSignals
        }, walletPrivateKey);
        
        // Update traditional database
        if (isCheckIn) {
            const attendance = new Attendance({
                scholarId,
                did: scholar.did,
                checkIn: new Date(),
                location: location || 'Main Campus',
                zkProof: {
                    commitment: proof.proof.a[0],
                    challenge: proof.proof.b[0][0],
                    response: proof.proof.c[0],
                    verificationKey: scholar.zkpPublicKey
                },
                verified: true,
                blockchainTxHash: blockchainResult.transactionHash,
                blockchainAttendanceId: blockchainResult.attendanceId
            });
            
            await attendance.save();
            
            res.json({
                message: 'Checked in successfully',
                checkIn: attendance.checkIn,
                location: attendance.location,
                blockchain: {
                    attendanceId: blockchainResult.attendanceId,
                    transactionHash: blockchainResult.transactionHash,
                    ipfsHash: blockchainResult.ipfsHash
                }
            });
        } else {
            existingAttendance.checkOut = new Date();
            existingAttendance.duration = 
                (existingAttendance.checkOut - existingAttendance.checkIn) / (1000 * 60 * 60);
            
            await existingAttendance.save();
            
            res.json({
                message: 'Checked out successfully',
                checkOut: existingAttendance.checkOut,
                duration: existingAttendance.duration.toFixed(2) + ' hours',
                blockchain: {
                    attendanceId: blockchainResult.attendanceId,
                    transactionHash: blockchainResult.transactionHash
                }
            });
        }
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// Verify attendance proof from blockchain
app.get('/api/attendance/verify-blockchain/:attendanceId', async (req, res) => {
    try {
        const { attendanceId } = req.params;
        const verification = await blockchainService.verifyAttendanceProof(attendanceId);
        
        res.json({
            verified: verification.verified,
            exists: verification.exists,
            scholar: verification.scholar,
            timestamp: verification.timestamp
        });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// Get blockchain attendance history
app.get('/api/scholar/blockchain-history/:walletAddress', authenticateToken, async (req, res) => {
    try {
        const { walletAddress } = req.params;
        const { offset = 0, limit = 50 } = req.query;
        
        const history = await blockchainService.getScholarAttendanceHistory(
            walletAddress,
            parseInt(offset),
            parseInt(limit)
        );
        
        res.json({ history });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});